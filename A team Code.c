#pragma config(Sensor, dgtl1,  flywheelLeftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  flywheelRightEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  flywheelLED,    sensorLEDtoVCC)
#pragma config(Motor,  port1,           waterwheel,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           driveTrainLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           flywheelLeft1, tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port4,           flywheelLeft2, tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port5,           rampLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rampRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           flywheelRight1, tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port8,           flywheelRight2, tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port9,           driveTrainRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          shooterConveyor, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "PIDController.h" //credit to JMMcKinneyWPI on Github, Jason McKinney for his PID control loop


#define DATALOG_FLYWHEEL_LEFT 0
#define DATALOG_FLYWHEEL_RIGHT 1

PID flywheelL, flywheelR; //The two pid structs to be monitored and used




/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

void driveFlywheelLeft(int output)
{

	motor[flywheelLeft1] = output;
	motor[flywheelLeft2] = output;
}

void driveFlywheelRight(int output)
{
	motor[flywheelRight1] = output;
	motor[flywheelRight2] = output;
}

float rpmAvgL = 0;
float rpmAvgR = 0;
float dT; //delta T in seconds
float outL, outR;
float sp = 1480;
bool set = false;

task usercontrol()
{

//INCREASE/DECREASE TARGET RPM (SP) WITH AN INCREMENT DECREMENT


	//flywheel PID initialization code
//		pidInit(flywheelL, 0.0, 0.004, 0.00, 0, 50);
//		pidInit(flywheelR, 0.0, 0.004, 0.00, 0, 50);
//	pidInit(flywheelL, 0.025, 0.020, 0.000, 0, 50);	//OLD FAIRLY GOOD
//		pidInit(flywheelR, 0.025, 0.020, 0.00, 0, 50);	//OLD FAIRLY GOOD
//		pidInit(flywheelL, .03, 0.02, 0.003, 0, 50);	//NEW BEST
//		pidInit(flywheelR, .03, 0.02, 0.003, 0, 50);	//NEW BEST
		pidInit(flywheelL, 0.4, 0.04, 0.003, 0, 50);	//NEW NEW BEST
		pidInit(flywheelR, 0.4, 0.04, 0.003, 0, 50);	//NEW NEW BEST
//			pidInit(flywheelL, 0.5, 0.04, 0.003, 0, 50);	//NEW NEW NEW BEST
//			pidInit(flywheelR, 0.5, 0.04, 0.003, 0, 50);	//NEW NEW NEW BEST
//		pidInit(flywheelL, 0.5, 0.05, 0.003, 0, 50);	//NEW NEW NEW BEST
//		pidInit(flywheelR, 0.5, 0.05, 0.003, 0, 50);
		unsigned long lastTime = nPgmTime;
		resetMotorEncoder(flywheelLeft1);
		resetMotorEncoder(flywheelRight1);
		bool runFlywheel = false;
		bool btn8DPressed = false;
		float rpmL, lastRpmL1, lastRpmL2, lastRpmL3, lastRpmL4;
		float rpmR, lastRpmR1, lastRpmR2, lastRpmR3, lastRpmR4;
		int counter = 0;

	// User control code here, inside the loop

	int currentFlywheelSpeed = 0;

//NOTES: Gear ratio now = 1:16.8
//RPM = 1680

	while (true)
	{
		int port3Drive = port3;
		//Flywheel PID work:

		dT = (float)(nPgmTime - lastTime)/1000;
		lastTime = nPgmTime;

		if(vexRT(Btn8D) && !btn8DPressed) //check if this = first time button = pressed
		{
			btn8DPressed = true;
			runFlywheel = !runFlywheel;

		}
		else if(!vexRT(Btn8D) && btn8DPressed)
		{
			btn8DPressed = false;
		}

		if(dT != 0) //*7 BECAUSE EXTERNAL RATIO = 1:7. Internal handled by / dT
		{
			rpmL = 60.00*7*(((float)getMotorEncoder(flywheelLeft1))/dT)/360; //360 w/ optical shaft encoder //261.3333 = for turbo gearing, 261.3333 ticks per rev in turbo gear
			rpmR = 60.00*7*(((float)getMotorEncoder(flywheelRight1))/dT)/360;
		}
		else
		{
			rpmL = 0;
			rpmR = 0;
		}
		resetMotorEncoder(flywheelLeft1);
		resetMotorEncoder(flywheelRight1);

		lastRpmL4 = lastRpmL3;
		lastRpmL3 = lastRpmL2;
		lastRpmL2 = lastRpmL1;
		lastRpmL1 = rpmL;

		lastRpmR4 = lastRpmR3;
		lastRpmR3 = lastRpmR2;
		lastRpmR2 = lastRpmR1;
		lastRpmR1 = rpmR;

		rpmAvgL = (rpmL + lastRpmL1 + lastRpmL2 + lastRpmL3 + lastRpmL4)/5;
		rpmAvgR = (rpmR + lastRpmR1 + lastRpmR2 + lastRpmR3 + lastRpmR4)/5;

		if(rpmAvgR >= sp-75 && rpmR <= sp+75 && rpmAvgL >= sp-75 && rpmL< sp+75)
		{
			counter++;
		}
		if(counter >= 3)
		{
			SensorValue(flywheelLED) = 1;
		}
		if(rpmAvgR < sp-150 || rpmR > sp+150 || rpmAvgL < sp-150 || rpmL > sp+150)
		{
			counter = 0;
			SensorValue(flywheelLED) = 0;
		}

/*		if(runFlywheel)
		{
			sp = 1180;
		}
		else
		{
			sp = 1480;
		}*/

		if(flywheelL.errorSum > 18000) // OLD: 20500
		{
			flywheelL.errorSum = 18000;
		}
		if(flywheelR.errorSum > 18000)
		{
			flywheelR.errorSum = 18000;
		}

		if(rpmAvgR >= sp && rpmAvgL >= sp && !set)
		{
			//flywheelL.errorSum = 0;
			//flywheelR.errorSum = 0;
			set = true;
		}
		if(rpmAvgR <= sp-700 && rpmAvgL <= sp-700)
		{
			set = false;
		}

//		if(vexRT(Btn8D) == 1)
//		{
			outL = pidExecute(flywheelL, sp-rpmAvgL);
			outR = pidExecute(flywheelR, sp-rpmAvgR);
			//		}
		if(vexRT(Btn8U) == 1)
		{
			pidReset(flywheelL);
			pidReset(flywheelR);
			outL = 0;
			outR = 0;
		}

		if(outL < 1)
		{
			outL = 1;
		}
		driveFlywheelLeft(outL);

		if(outR < 1)
		{
			outR = 1;
		}
		driveFlywheelRight(outR);

  	//motors direct mapping from up/down joysticks

		motor[driveTrainRight] = vexRT[Ch2];
  	motor[driveTrainLeft] = vexRT[Ch3];

  	//conveyor sets
  	int shooterConveyorOn = vexRT[Btn7D];
  	int shooterConveyorOff = vexRT[Btn7U];
  	int shooterConveyorOut = vexRT[Btn7R];

  	//waterwheel sets
  	int waterwheelIn = vexRT[Btn7DXmtr2]; //to use partner joystick append Xmtr2
		int waterwheelOff = vexRT[Btn7UXmtr2];
		int waterwheelOut = vexRT[Btn7RXmtr2];

		//flywheel sets
		int maxFlywheel = vexRT[Btn8D];
		int flywheelIncrement = vexRT[Btn8R];
		int flywheelDecrement = vexRT[Btn8L];
		int flywheelOff = vexRT[Btn8U];

		//ramp sets
		int rampLeftDown = vexRT[Btn5D];
		int rampLeftUp = vexRT[Btn6D];
		int rampRightDown = vexRT[Btn6D];
		int rampRightUp = vexRT[Btn6U];


		//waterwheel control code
		if(waterwheelIn == 1)
		{
			motor[waterwheel] = 127;
		}
		else if(waterwheelOut == 1)
		{
			motor[waterwheel] = -127;
		}
		else if(waterwheelOff == 1)
		{
			motor[waterwheel] = 0;
		}
		//shooter conveyor control code

		if(shooterConveyorOn == 1)
		{
			motor[shooterConveyor] = 127;
		}
		else if(shooterConveyorOut == 1)
		{
			motor[shooterConveyor] = -127;
		}
		else if(shooterConveyorOff == 1)
		{
			motor[shooterConveyor] = 0;
		}

  	//flywheel control code



		/*if(maxFlywheel == 1)
		{
			motor[flywheelLeft] = 81;
			motor[flywheelRight] = 81;
			currentFlywheelSpeed = 81;

		}
		else if(flywheelIncrement == 1)
		{

			currentFlywheelSpeed += 2;
			motor[flywheelLeft] = currentFlywheelSpeed;
			motor[flywheelRight] = currentFlywheelSpeed;
			wait1Msec(500);
		}
		else if(flywheelDecrement == 1)
		{
			currentFlywheelSpeed -= 2;
			motor[flywheelLeft] = currentFlywheelSpeed;
			motor[flywheelRight] = currentFlywheelSpeed;
			wait1Msec(500);
		}
		else if(flywheelOff == 1)
		{
			motor[flywheelLeft] = 0;
			motor[flywheelRight] = 0;
		}*/

		//ramp control code



		if( rampLeftDown == 1)
		{
			motor[rampLeft] = 127;
		}
		else if( rampLeftUp == 1)
		{
			motor[rampLeft] = -127;
		}
		else
		{
			motor[rampLeft] = 0;
		}

		if( rampRightDown == 1)
		{
			motor[rampRight] = 127;
		}
		else if( rampRightUp == 1)
		{
			motor[rampRight] = -127;
		}
		else
		{
			motor[rampRight] = 0;
	}


//		datalogDataGroupStart();
//		datalogAddValueWithTimeStamp(DATALOG_FLYWHEEL_LEFT, rpmL);
//		datalogAddValueWithTimeStamp(DATALOG_FLYWHEEL_RIGHT, rpmR);

	/*	datalogAddValueWithTimeStamp(0, flywheelLeft2);
		datalogAddValueWithTimeStamp(0, flywheelRight1);
		datalogAddValueWithTimeStamp(0, flywheelRight2);
		datalogAddValueWithTimeStamp(0, flywheelLeftEncoder);
		datalogAddValueWithTimeStamp(0, flywheelRightEncoder);*/

//		datalogDataGroupEnd();





	}
}
