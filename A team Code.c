#pragma config(Sensor, dgtl1,  flywheelLeftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  flywheelRightEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  flywheelLED,    sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  driveLeftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  driveRightEncoder, sensorQuadEncoder)
#pragma config(Motor,  port1,           waterwheel,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           driveTrainLeft, tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl6)
#pragma config(Motor,  port3,           flywheelLeft1, tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port4,           flywheelLeft2, tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port5,           rampLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rampRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           flywheelRight1, tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port8,           flywheelRight2, tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port9,           driveTrainRight, tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, dgtl8)
#pragma config(Motor,  port10,          shooterConveyor, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*Future todo:
Check integral windup, potentially lower cap from 18000. TEST
*/

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "PIDController.h" //CREDIT TO: JMMcKinneyWPI on Github, Jason McKinney for his PID control loop
#include "gyro.c" //CREDIT TO: JMMcKinneyWPI on Github, Jason McKinney for his gyro PID loop

#define DATALOG_FLYWHEEL_LEFT 0
#define DATALOG_FLYWHEEL_RIGHT 1

PID flywheelL, flywheelR; //The two pid structs to be monitored and used
PID gyroPid;
PID drivePidL, drivePidR;
float setAngle = 90;



/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////


void driveFlywheelLeft(int output)
{

	motor[flywheelLeft1] = output;
	motor[flywheelLeft2] = output;
}

void driveFlywheelRight(int output)
{
	motor[flywheelRight1] = output;
	motor[flywheelRight2] = output;
}


void driveL(int val)
{
	if(abs(val) > 127)
		val = 127 * val/abs(val);

	motor[port2] = val;
}

//Power right drive motors
void driveR(int val)
{
	if(abs(val) > 127)
		val = 127 * val/abs(val);

	motor[port9] = val;
}
void pidDrive(int target)
{

		pidInit(drivePidL, 1.1, 0.015, 0.2, 1, 1270);
		pidInit(drivePidR, 1.1, 0.015, 0.2, 1, 1270);
		resetMotorEncoder(driveTrainLeft);
		resetMotorEncoder(driveTrainRight);
		bool atDestination = false;
		long atTargetTime = nPgmTime;
		long timer = nPgmTime;
		float degreesTravelledL = 0;
		float degreesTravelledR = 0;

	while(!atDestination)
	{
		//Calculate the delta time from the last iteration of the loop
		float dT = (float)(nPgmTime - timer)/1000;

		//Calculate the current angle of the gyro
		degreesTravelledL = getMotorEncoder(driveTrainLeft);
		degreesTravelledR = getMotorEncoder(driveTrainRight);
				writeDebugStreamLine("%f", degreesTravelledR);
		//Reset loop timer
		timer = nPgmTime;

		//Calculate the output of the PID controller and output to drive motors
		float errorL = (float)target - degreesTravelledL;
		float errorR = (float)target - degreesTravelledR;
		float driveOutL = pidExecute(drivePidL, errorL);
		float driveOutR = pidExecute(drivePidR, errorR);
		driveL(driveOutL);
		driveR(driveOutR);

		//Stop the turn function when the angle has been within 3 degrees of the desired angle for 350ms
		if(abs(errorL) > 7 && abs(errorR) > 7)
			atTargetTime = nPgmTime;
		if(nPgmTime - atTargetTime > 350)
		{
			atDestination = true;
		}
	}
}


//Gyro turn to target angle CREDIT Jason McKinney
void gyroTurn(float target) //DO NOT USE GYRO TURNS LESS THAN 20 degrees
{
	//various gyro pid "ranges" Different pid constants handle different degree turns better/worse (without integral).
	if(abs(target) >= 80 )
	{
     	pidInit(gyroPid, 3.2,0, 0.11, 3, 127);
	}
	if(abs(target) > 40 && abs(target) < 80 )
	{
     	pidInit(gyroPid, 3.45, 0, 0.08, 3, 127);
	}

	if(abs(target) <= 40 && abs(target) > 25 )
	{
		pidInit(gyroPid, 3.9, 0, 0.05, 3, 127);
	}
	if(abs(target) <= 25 && abs(target) > 20 )
	{
		pidInit(gyroPid, 4.2, 0, 0.03, 3, 127);
	}
	if(abs(target) <= 20 && abs(target) > 17 )
	{
		pidInit(gyroPid, 4.5, 0, 0.01, 3, 127);
	}
	bool atGyro = false;
	long atTargetTime = nPgmTime;
	long timer = nPgmTime;

	pidReset(gyroPid);
	gyroResetAngle();
	while(!atGyro)
	{
		//Calculate the delta time from the last iteration of the loop
		float dT = (float)(nPgmTime - timer)/1000;

		//Calculate the current angle of the gyro
		float angle = gyroAddAngle(dT);
		writeDebugStreamLine("%f", angle);
		//Reset loop timer
		timer = nPgmTime;

		//Calculate the output of the PID controller and output to drive motors
		float error = (float)target - angle;
		float driveOut = pidExecute(gyroPid, error);
		driveL(-driveOut);
		driveR(driveOut);

		//Stop the turn function when the angle has been within 3 degrees of the desired angle for 350ms
		if(abs(error) > 3)
			atTargetTime = nPgmTime;
		if(nPgmTime - atTargetTime > 350)
		{
			atGyro = true;
			driveL(0);
			driveR(0);
		}

	}

	//Reinitialize the PID constants to their original values in case they were changed
pidInit(gyroPid, 3.2,0, 0.11, 3, 127);
}

void pre_auton()
{

	//CREDIT TO: JMMcKinneyWPI on Github, Jason McKinney for his gyro PID loop
 	gyroSetPort(in1);

 	//Allow gyro to settle and then calibrate (about 3 seconds overall)
 	delay(1100);
//	SensorValue[calibrationInProgress] = 1;
	gyroCalibrate();
//	SensorValue[calibrationInProgress] = 0;
	/*Initialize PID controller for gyro
	 * kP = 2, kI = 0, kD = 0.15
	 * epsilon = 0, slewRate = 1270
	*/
	pidInit(gyroPid, 3.1, 0, 0.11, 3, 127);


//	bStopTasksBetweenModes = false;
	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////


float rpmAvgL = 0;
float rpmAvgR = 0;
float dT; //delta T in seconds
float outL, outR;
float sp = 1575;// used to be 1575
bool set = false;


task autonomous()
{

	clearTimer(T1);
		int firstBall = 0;
		pidInit(flywheelL, 0.3, 0.1, -0.00007, 3, 50);	//NEW NEW BEST
		pidInit(flywheelR, 0.3, 0.1, -0.00007, 3, 50);	//NEW NEW BEST
		unsigned long lastTime = nPgmTime;
		resetMotorEncoder(flywheelLeft1);
		resetMotorEncoder(flywheelRight1);
		bool runFlywheel = false;
		bool btn8DPressed = false;
		float rpmL, lastRpmL1, lastRpmL2, lastRpmL3, lastRpmL4;
		float rpmR, lastRpmR1, lastRpmR2, lastRpmR3, lastRpmR4;
		int counter = 0;


	while(1==1)
	{

		dT = (float)(nPgmTime - lastTime)/1000;
			lastTime = nPgmTime;

		/*	if(vexRT(Btn8D) && !btn8DPressed) //check if this = first time button = pressed
			{
				btn8DPressed = true;
				runFlywheel = !runFlywheel;

			}
			else if(!vexRT(Btn8D) && btn8DPressed)
			{
				btn8DPressed = false;
			}*/

			if(dT != 0) //*7 BECAUSE EXTERNAL RATIO = 1:7. Internal handled by / dT
			{
				rpmL = 60.00*7*(((float)getMotorEncoder(flywheelLeft1))/dT)/360; //360 w/ optical shaft encoder //261.3333 = for turbo gearing, 261.3333 ticks per rev in turbo gear
				rpmR = 60.00*7*(((float)getMotorEncoder(flywheelRight1))/dT)/360;
			}
			else
			{
				rpmL = 0;
				rpmR = 0;
			}
			resetMotorEncoder(flywheelLeft1);
			resetMotorEncoder(flywheelRight1);

			lastRpmL4 = lastRpmL3;
			lastRpmL3 = lastRpmL2;
			lastRpmL2 = lastRpmL1;
			lastRpmL1 = rpmL;

			lastRpmR4 = lastRpmR3;
			lastRpmR3 = lastRpmR2;
			lastRpmR2 = lastRpmR1;
			lastRpmR1 = rpmR;

			rpmAvgL = (rpmL + lastRpmL1 + lastRpmL2 + lastRpmL3 + lastRpmL4)/5;
			rpmAvgR = (rpmR + lastRpmR1 + lastRpmR2 + lastRpmR3 + lastRpmR4)/5;

			if(rpmAvgR >= sp-75 && rpmR <= sp+75 && rpmAvgL >= sp-75 && rpmL< sp+75)
			{
				counter++;
			}
			if(counter >= 3)
			{
				SensorValue(flywheelLED) = 1;
			}
			if(rpmAvgR < sp-150 || rpmR > sp+150 || rpmAvgL < sp-150 || rpmL > sp+150)
			{
				counter = 0;
				SensorValue(flywheelLED) = 0;
			}

	/*		if(runFlywheel)
			{
				sp = 1180;
			}
			else
			{
				sp = 1480;
			}*/

			if(flywheelL.errorSum > 18000) // OLD: 20500
			{
				flywheelL.errorSum = 18000;
			}
			if(flywheelR.errorSum > 18000)
			{
				flywheelR.errorSum = 18000;
			}

			if(rpmAvgR >= sp && rpmAvgL >= sp && !set)
			{
				//flywheelL.errorSum = 0;
				//flywheelR.errorSum = 0;
				set = true;
			}
			if(rpmAvgR <= sp-700 && rpmAvgL <= sp-700)
			{
				set = false;
			}

			outL = pidExecute(flywheelL, sp-rpmAvgL);
			outR = pidExecute(flywheelR, sp-rpmAvgR);

			if(outL < 1)
			{
				outL = 1;
			}
			driveFlywheelLeft(outL);

			if(outR < 1)
			{
				outR = 1;
			}
			driveFlywheelRight(outR);

			if(time1[T1] > 1800) //old 2000
			{

				motor[waterwheel] = 127;
				motor[shooterConveyor] = 127;
				firstBall = 1;
			}
			if(time1[T1] > 8500 && time1[T1] < 9500)//red side
			{
				int newSp = 1400;
				outL = pidExecute(flywheelL, newSp-rpmAvgL);
				outR = pidExecute(flywheelR, newSp-rpmAvgR);
				driveFlywheelLeft(outL);
				driveFlywheelRight(outR);
				gyroTurn(-35);
				pidDrive(1000);
				//wait1Msec(10000);
				gyroTurn(75);
				clearTimer(T2);
				while(time1[T2] < 800)
				{
					driveL(-127);
					driveR(-127);
				}
				while(time1[T2] < 1350)
				{
					driveL(127);
					driveR(127);
				}
				while(time1[T2] < 2150)
				{
					driveL(-127);
					driveR(-127);
				}
				pidDrive(180);
				gyroTurn(-33);
			}
		/*		if(time1[T1] > 8500 && time1[T1] < 9500)//blue side
			{
				int newSp = 1400;
				outL = pidExecute(flywheelL, newSp-rpmAvgL);
				outR = pidExecute(flywheelR, newSp-rpmAvgR);
				driveFlywheelLeft(outL);
				driveFlywheelRight(outR);
				gyroTurn(35);
				pidDrive(1000);
				//wait1Msec(10000);
				gyroTurn(-75);
				clearTimer(T2);
				while(time1[T2] < 800)
				{
					driveL(-127);
					driveR(-127);
				}
				while(time1[T2] < 1350)
				{
					driveL(127);
					driveR(127);
				}
				while(time1[T2] < 2150)
				{
					driveL(-127);
					driveR(-127);
				}
				pidDrive(180);
				gyroTurn(33);
			}*/

			wait1Msec(20);

		}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	pidDrive(1000);
//	wait1Msec(10000);
	pidReset(flywheelL);
	pidReset(flywheelR);
	debugStreamClear;
float sp = 1520; // old 1480
//INCREASE/DECREASE TARGET RPM (SP) WITH AN INCREMENT DECREMENTalea


	//flywheel PID initialization code
//		pidInit(flywheelL, 0.0, 0.004, 0.00, 0, 50);
//		pidInit(flywheelR, 0.0, 0.004, 0.00, 0, 50);
//	pidInit(flywheelL, 0.025, 0.020, 0.000, 0, 50);	//OLD FAIRLY GOOD
//		pidInit(flywheelR, 0.025, 0.020, 0.00, 0, 50);	//OLD FAIRLY GOOD
//		pidInit(flywheelL, .03, 0.02, 0.003, 0, 50);	//NEW BEST
//		pidInit(flywheelR, .03, 0.02, 0.003, 0, 50);	//NEW BEST
//		pidInit(flywheelL, 0.4, 0.04, 0.003, 0, 50);	//NEW NEW BEST   COMPETITION CODE
//		pidInit(flywheelR, 0.4, 0.04, 0.003, 0, 50);	//NEW NEW BEST

//		pidInit(flywheelL, 0.5, 0.05, -0.001,0, 50);	//NEW NEW BEST
//		pidInit(flywheelR, 0.5, 0.05, -0.001, 0, 50);	//NEW NEW BEST




//NEW PID LOOP TUNING
//pidInit(flywheelL, 2.9, 0.00001, 0.0515, 3, 50);	//NEW NEW BEST
	//	pidInit(flywheelR, 2.9, 0.00001, 0.0515, 3, 50);	//NEW NEW BEST



//BESTEST
//			pidInit(flywheelL, 0.3, 0.0000, 0.00007, 3, 50);	//NEW NEW BEST
//		pidInit(flywheelR, 0.3, 0.0000, 0.00007, 3, 50);	//NEW NEW BEST



//SUPER DUPER BESTEST *** CONGRATS *** YOU DID GREAT*** I'M SO PROUD OF YOU ***
		//pidInit(flywheelL, 0.3, 0.1, 0.00007, 3, 50);	//NEW NEW BEST
		//pidInit(flywheelR, 0.3, 0.1, 0.00007, 3, 50);	//NEW NEW BEST

		pidInit(flywheelL, 0.3, 0.1, -0.00007, 3, 50);	//NEW NEW BEST
		pidInit(flywheelR, 0.3, 0.1, -0.00007, 3, 50);	//NEW NEW BEST



		unsigned long lastTime = nPgmTime;
		resetMotorEncoder(flywheelLeft1);
		resetMotorEncoder(flywheelRight1);
		bool runFlywheel = false;
		bool btn8DPressed = false;
		float rpmL, lastRpmL1, lastRpmL2, lastRpmL3, lastRpmL4;
		float rpmR, lastRpmR1, lastRpmR2, lastRpmR3, lastRpmR4;
		int counter = 0;

	// User control code here, inside the loop

	int currentFlywheelSpeed = 0;

//NOTES: Gear ratio now = 1:16.8
//RPM = 1680

	while (true)
	{
		//Flywheel PID work:


		if(vexRT(Btn8D) == 1)
		{
			btn8DPressed = true;
		}
		if(btn8DPressed == true)
		{

			dT = (float)(nPgmTime - lastTime)/1000;
			lastTime = nPgmTime;

		/*	if(vexRT(Btn8D) && !btn8DPressed) //check if this = first time button = pressed
			{
				btn8DPressed = true;
				runFlywheel = !runFlywheel;

			}
			else if(!vexRT(Btn8D) && btn8DPressed)
			{
				btn8DPressed = false;
			}*/

			if(dT != 0) //*7 BECAUSE EXTERNAL RATIO = 1:7. Internal handled by / dT
			{
				rpmL = 60.00*7*(((float)getMotorEncoder(flywheelLeft1))/dT)/360; //360 w/ optical shaft encoder //261.3333 = for turbo gearing, 261.3333 ticks per rev in turbo gear
				rpmR = 60.00*7*(((float)getMotorEncoder(flywheelRight1))/dT)/360;
			}
			else
			{
				rpmL = 0;
				rpmR = 0;
			}
			resetMotorEncoder(flywheelLeft1);
			resetMotorEncoder(flywheelRight1);

			lastRpmL4 = lastRpmL3;
			lastRpmL3 = lastRpmL2;
			lastRpmL2 = lastRpmL1;
			lastRpmL1 = rpmL;

			lastRpmR4 = lastRpmR3;
			lastRpmR3 = lastRpmR2;
			lastRpmR2 = lastRpmR1;
			lastRpmR1 = rpmR;

			rpmAvgL = (rpmL + lastRpmL1 + lastRpmL2 + lastRpmL3 + lastRpmL4)/5;
			rpmAvgR = (rpmR + lastRpmR1 + lastRpmR2 + lastRpmR3 + lastRpmR4)/5;

				if(rpmAvgR >= sp-50 && rpmR <= sp+50 && rpmAvgL >= sp-50 && rpmL< sp+50)
			{
				counter++;
			}
			if(counter >= 3)
			{
				SensorValue(flywheelLED) = 1;
			}
			if(rpmAvgR < sp-150 || rpmR > sp+150 || rpmAvgL < sp-150 || rpmL > sp+150)
			{
				counter = 0;
				SensorValue(flywheelLED) = 0;
			}

		/*	if(rpmAvgR >= sp-75 && rpmR <= sp+75 && rpmAvgL >= sp-75 && rpmL< sp+75)
			{
				counter++;
			}
			if(counter >= 3)
			{
				SensorValue(flywheelLED) = 1;
			}
			if(rpmAvgR < sp-150 || rpmR > sp+150 || rpmAvgL < sp-150 || rpmL > sp+150)
			{
				counter = 0;
				SensorValue(flywheelLED) = 0;
			}*/

	/*		if(runFlywheel)
			{
				sp = 1180;
			}
			else
			{
				sp = 1480;
			}*/

			if(flywheelL.errorSum > 18000) // OLD: 20500    //OLD BEST = 18000,
			{
				flywheelL.errorSum = 18000;
			}
			if(flywheelR.errorSum > 18000)
			{
				flywheelR.errorSum = 18000;
			}

			if(rpmAvgR >= sp && rpmAvgL >= sp && !set)
			{
				//flywheelL.errorSum = 0;
				//flywheelR.errorSum = 0;
				set = true;
			}
			if(rpmAvgR <= sp-700 && rpmAvgL <= sp-700)
			{
				set = false;
			}

				outL = pidExecute(flywheelL, sp-rpmAvgL);
				outR = pidExecute(flywheelR, sp-rpmAvgR);

			if(vexRT(Btn8U) == 1)
			{
				btn8DPressed = false;
				pidReset(flywheelL);
				pidReset(flywheelR);
				outL = 0;
				outR = 0;
			}

			if(vexRT(Btn8L) == 1)
			{
				sp -= 5;
				wait1Msec(500);
			}

			if(vexRT(Btn8R) == 1)
			{
				sp += 5;
				wait1Msec(500);
			}


			if(outL < 1)
			{
				outL = 1;
			}
			driveFlywheelLeft(outL);

			if(outR < 1)
			{
				outR = 1;
			}
			driveFlywheelRight(outR);
		}

  	//motors direct mapping from up/down joysticks

		motor[driveTrainRight] = vexRT[Ch2];
  	motor[driveTrainLeft] = vexRT[Ch3];

  	//conveyor sets
  	int shooterConveyorOn = vexRT[Btn7D];
  	int shooterConveyorOff = vexRT[Btn7U];
  	int shooterConveyorOut = vexRT[Btn7R];

  	//waterwheel sets
  	int waterwheelIn = vexRT[Btn7DXmtr2]; //to use partner joystick append Xmtr2
		int waterwheelOff = vexRT[Btn7UXmtr2];
		int waterwheelOut = vexRT[Btn7RXmtr2];

		//flywheel sets
		int maxFlywheel = vexRT[Btn8D];
		int flywheelIncrement = vexRT[Btn8R];
		int flywheelDecrement = vexRT[Btn8L];
		int flywheelOff = vexRT[Btn8U];

		//ramp sets
		int rampLeftDown = vexRT[Btn5D];
		int rampLeftUp = vexRT[Btn5U];
		int rampRightDown = vexRT[Btn6D];
		int rampRightUp = vexRT[Btn6U];


		//waterwheel control code
		if(waterwheelIn == 1)
		{
			motor[waterwheel] = 127;
		}
		else if(waterwheelOut == 1)
		{
			motor[waterwheel] = -127;
		}
		else if(waterwheelOff == 1)
		{
			motor[waterwheel] = 0;
		}
		//shooter conveyor control code

		if(shooterConveyorOn == 1)
		{
			motor[shooterConveyor] = 127;
		}
		else if(shooterConveyorOut == 1)
		{
			motor[shooterConveyor] = -127;
		}
		else if(shooterConveyorOff == 1)
		{
			motor[shooterConveyor] = 0;
		}

  	//flywheel control code



		/*if(maxFlywheel == 1)
		{
			motor[flywheelLeft] = 81;
			motor[flywheelRight] = 81;
			currentFlywheelSpeed = 81;

		}
		else if(flywheelIncrement == 1)
		{

			currentFlywheelSpeed += 2;
			motor[flywheelLeft] = currentFlywheelSpeed;
			motor[flywheelRight] = currentFlywheelSpeed;
			wait1Msec(500);
		}
		else if(flywheelDecrement == 1)
		{
			currentFlywheelSpeed -= 2;
			motor[flywheelLeft] = currentFlywheelSpeed;
			motor[flywheelRight] = currentFlywheelSpeed;
			wait1Msec(500);
		}
		else if(flywheelOff == 1)
		{
			motor[flywheelLeft] = 0;
			motor[flywheelRight] = 0;
		}*/

		//ramp control code



		if( rampLeftDown == 1)
		{
			motor[rampLeft] = 127;
		}
		else if( rampLeftUp == 1)
		{
			motor[rampLeft] = -127;
		}
		else
		{
			motor[rampLeft] = 0;
		}

		if( rampRightDown == 1)
		{
			motor[rampRight] = 127;
		}
		else if( rampRightUp == 1)
		{
			motor[rampRight] = -127;
		}
		else
		{
			motor[rampRight] = 0;
	}


	//	datalogDataGroupStart();
	//	datalogAddValueWithTimeStamp(DATALOG_FLYWHEEL_LEFT, rpmL);
//		datalogAddValueWithTimeStamp(DATALOG_FLYWHEEL_RIGHT, rpmR);

	/*	datalogAddValueWithTimeStamp(0, flywheelLeft2);
		datalogAddValueWithTimeStamp(0, flywheelRight1);
		datalogAddValueWithTimeStamp(0, flywheelRight2);
		datalogAddValueWithTimeStamp(0, flywheelLeftEncoder);
		datalogAddValueWithTimeStamp(0, flywheelRightEncoder);*/

//		datalogDataGroupEnd();
writeDebugStreamLine("%f", rpmR);
		wait1Msec(20);




	}
}
